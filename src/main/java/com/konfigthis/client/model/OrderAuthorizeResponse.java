/*
 * Orders
 * An order represents a payment between two or more parties. Use the Orders API to create, update, retrieve, authorize, and capture orders.
 *
 * The version of the OpenAPI document: 2.13
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.konfigthis.client.model.CheckoutPaymentIntent;
import com.konfigthis.client.model.LinkDescription;
import com.konfigthis.client.model.OrderStatus;
import com.konfigthis.client.model.Payer;
import com.konfigthis.client.model.PaymentSourceResponse;
import com.konfigthis.client.model.ProcessingInstruction;
import com.konfigthis.client.model.PurchaseUnit;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import org.apache.commons.lang3.StringUtils;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.konfigthis.client.JSON;

/**
 * The order authorize response.
 */
@ApiModel(description = "The order authorize response.")@javax.annotation.Generated(value = "Generated by https://konfigthis.com")
public class OrderAuthorizeResponse {
  public static final String SERIALIZED_NAME_CREATE_TIME = "create_time";
  @SerializedName(SERIALIZED_NAME_CREATE_TIME)
  private String createTime;

  public static final String SERIALIZED_NAME_UPDATE_TIME = "update_time";
  @SerializedName(SERIALIZED_NAME_UPDATE_TIME)
  private String updateTime;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_PAYMENT_SOURCE = "payment_source";
  @SerializedName(SERIALIZED_NAME_PAYMENT_SOURCE)
  private PaymentSourceResponse paymentSource;

  public static final String SERIALIZED_NAME_INTENT = "intent";
  @SerializedName(SERIALIZED_NAME_INTENT)
  private CheckoutPaymentIntent intent;

  public static final String SERIALIZED_NAME_PROCESSING_INSTRUCTION = "processing_instruction";
  @SerializedName(SERIALIZED_NAME_PROCESSING_INSTRUCTION)
  private ProcessingInstruction processingInstruction = ProcessingInstruction.NO_INSTRUCTION;

  public static final String SERIALIZED_NAME_PAYER = "payer";
  @SerializedName(SERIALIZED_NAME_PAYER)
  private Payer payer;

  public static final String SERIALIZED_NAME_PURCHASE_UNITS = "purchase_units";
  @SerializedName(SERIALIZED_NAME_PURCHASE_UNITS)
  private List<PurchaseUnit> purchaseUnits = null;

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private OrderStatus status;

  public static final String SERIALIZED_NAME_LINKS = "links";
  @SerializedName(SERIALIZED_NAME_LINKS)
  private List<LinkDescription> links = null;

  public OrderAuthorizeResponse() {
  }

  
  public OrderAuthorizeResponse(
     String id, 
     List<LinkDescription> links
  ) {
    this();
    this.id = id;
    this.links = links;
  }

  public OrderAuthorizeResponse createTime(String createTime) {
    
    
    if (createTime != null && createTime.length() < 20) {
      throw new IllegalArgumentException("Invalid value for createTime. Length must be greater than or equal to 20.");
    }
    
    this.createTime = createTime;
    return this;
  }

   /**
   * The date and time, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). Seconds are required while fractional seconds are optional.&lt;blockquote&gt;&lt;strong&gt;Note:&lt;/strong&gt; The regular expression provides guidance but does not reject all invalid dates.&lt;/blockquote&gt;
   * @return createTime
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The date and time, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). Seconds are required while fractional seconds are optional.<blockquote><strong>Note:</strong> The regular expression provides guidance but does not reject all invalid dates.</blockquote>")

  public String getCreateTime() {
    return createTime;
  }


  public void setCreateTime(String createTime) {
    
    
    if (createTime != null && createTime.length() < 20) {
      throw new IllegalArgumentException("Invalid value for createTime. Length must be greater than or equal to 20.");
    }
    this.createTime = createTime;
  }


  public OrderAuthorizeResponse updateTime(String updateTime) {
    
    
    if (updateTime != null && updateTime.length() < 20) {
      throw new IllegalArgumentException("Invalid value for updateTime. Length must be greater than or equal to 20.");
    }
    
    this.updateTime = updateTime;
    return this;
  }

   /**
   * The date and time, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). Seconds are required while fractional seconds are optional.&lt;blockquote&gt;&lt;strong&gt;Note:&lt;/strong&gt; The regular expression provides guidance but does not reject all invalid dates.&lt;/blockquote&gt;
   * @return updateTime
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The date and time, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). Seconds are required while fractional seconds are optional.<blockquote><strong>Note:</strong> The regular expression provides guidance but does not reject all invalid dates.</blockquote>")

  public String getUpdateTime() {
    return updateTime;
  }


  public void setUpdateTime(String updateTime) {
    
    
    if (updateTime != null && updateTime.length() < 20) {
      throw new IllegalArgumentException("Invalid value for updateTime. Length must be greater than or equal to 20.");
    }
    this.updateTime = updateTime;
  }


   /**
   * The ID of the order.
   * @return id
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The ID of the order.")

  public String getId() {
    return id;
  }




  public OrderAuthorizeResponse paymentSource(PaymentSourceResponse paymentSource) {
    
    
    
    
    this.paymentSource = paymentSource;
    return this;
  }

   /**
   * Get paymentSource
   * @return paymentSource
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public PaymentSourceResponse getPaymentSource() {
    return paymentSource;
  }


  public void setPaymentSource(PaymentSourceResponse paymentSource) {
    
    
    
    this.paymentSource = paymentSource;
  }


  public OrderAuthorizeResponse intent(CheckoutPaymentIntent intent) {
    
    
    
    
    this.intent = intent;
    return this;
  }

   /**
   * Get intent
   * @return intent
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public CheckoutPaymentIntent getIntent() {
    return intent;
  }


  public void setIntent(CheckoutPaymentIntent intent) {
    
    
    
    this.intent = intent;
  }


  public OrderAuthorizeResponse processingInstruction(ProcessingInstruction processingInstruction) {
    
    
    
    
    this.processingInstruction = processingInstruction;
    return this;
  }

   /**
   * Get processingInstruction
   * @return processingInstruction
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public ProcessingInstruction getProcessingInstruction() {
    return processingInstruction;
  }


  public void setProcessingInstruction(ProcessingInstruction processingInstruction) {
    
    
    
    this.processingInstruction = processingInstruction;
  }


  public OrderAuthorizeResponse payer(Payer payer) {
    
    
    
    
    this.payer = payer;
    return this;
  }

   /**
   * Get payer
   * @return payer
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public Payer getPayer() {
    return payer;
  }


  public void setPayer(Payer payer) {
    
    
    
    this.payer = payer;
  }


  public OrderAuthorizeResponse purchaseUnits(List<PurchaseUnit> purchaseUnits) {
    
    
    
    
    this.purchaseUnits = purchaseUnits;
    return this;
  }

  public OrderAuthorizeResponse addPurchaseUnitsItem(PurchaseUnit purchaseUnitsItem) {
    if (this.purchaseUnits == null) {
      this.purchaseUnits = new ArrayList<>();
    }
    this.purchaseUnits.add(purchaseUnitsItem);
    return this;
  }

   /**
   * An array of purchase units. Each purchase unit establishes a contract between a customer and merchant. Each purchase unit represents either a full or partial order that the customer intends to purchase from the merchant.
   * @return purchaseUnits
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "An array of purchase units. Each purchase unit establishes a contract between a customer and merchant. Each purchase unit represents either a full or partial order that the customer intends to purchase from the merchant.")

  public List<PurchaseUnit> getPurchaseUnits() {
    return purchaseUnits;
  }


  public void setPurchaseUnits(List<PurchaseUnit> purchaseUnits) {
    
    
    
    this.purchaseUnits = purchaseUnits;
  }


  public OrderAuthorizeResponse status(OrderStatus status) {
    
    
    
    
    this.status = status;
    return this;
  }

   /**
   * Get status
   * @return status
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public OrderStatus getStatus() {
    return status;
  }


  public void setStatus(OrderStatus status) {
    
    
    
    this.status = status;
  }


   /**
   * An array of request-related HATEOAS links. To complete payer approval, use the &#x60;approve&#x60; link to redirect the payer. The API caller has 3 hours (default setting, this which can be changed by your account manager to 24/48/72 hours to accommodate your use case) from the time the order is created, to redirect your payer. Once redirected, the API caller has 3 hours for the payer to approve the order and either authorize or capture the order. If you are not using the PayPal JavaScript SDK to initiate PayPal Checkout (in context) ensure that you include &#x60;application_context.return_url&#x60; is specified or you will get \&quot;We&#39;re sorry, Things don&#39;t appear to be working at the moment\&quot; after the payer approves the payment.
   * @return links
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "An array of request-related HATEOAS links. To complete payer approval, use the `approve` link to redirect the payer. The API caller has 3 hours (default setting, this which can be changed by your account manager to 24/48/72 hours to accommodate your use case) from the time the order is created, to redirect your payer. Once redirected, the API caller has 3 hours for the payer to approve the order and either authorize or capture the order. If you are not using the PayPal JavaScript SDK to initiate PayPal Checkout (in context) ensure that you include `application_context.return_url` is specified or you will get \"We're sorry, Things don't appear to be working at the moment\" after the payer approves the payment.")

  public List<LinkDescription> getLinks() {
    return links;
  }



  /**
   * A container for additional, undeclared properties.
   * This is a holder for any undeclared properties as specified with
   * the 'additionalProperties' keyword in the OAS document.
   */
  private Map<String, Object> additionalProperties;

  /**
   * Set the additional (undeclared) property with the specified name and value.
   * If the property does not already exist, create it otherwise replace it.
   *
   * @param key name of the property
   * @param value value of the property
   * @return the OrderAuthorizeResponse instance itself
   */
  public OrderAuthorizeResponse putAdditionalProperty(String key, Object value) {
    if (this.additionalProperties == null) {
        this.additionalProperties = new HashMap<String, Object>();
    }
    this.additionalProperties.put(key, value);
    return this;
  }

  /**
   * Return the additional (undeclared) property.
   *
   * @return a map of objects
   */
  public Map<String, Object> getAdditionalProperties() {
    return additionalProperties;
  }

  /**
   * Return the additional (undeclared) property with the specified name.
   *
   * @param key name of the property
   * @return an object
   */
  public Object getAdditionalProperty(String key) {
    if (this.additionalProperties == null) {
        return null;
    }
    return this.additionalProperties.get(key);
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    OrderAuthorizeResponse orderAuthorizeResponse = (OrderAuthorizeResponse) o;
    return Objects.equals(this.createTime, orderAuthorizeResponse.createTime) &&
        Objects.equals(this.updateTime, orderAuthorizeResponse.updateTime) &&
        Objects.equals(this.id, orderAuthorizeResponse.id) &&
        Objects.equals(this.paymentSource, orderAuthorizeResponse.paymentSource) &&
        Objects.equals(this.intent, orderAuthorizeResponse.intent) &&
        Objects.equals(this.processingInstruction, orderAuthorizeResponse.processingInstruction) &&
        Objects.equals(this.payer, orderAuthorizeResponse.payer) &&
        Objects.equals(this.purchaseUnits, orderAuthorizeResponse.purchaseUnits) &&
        Objects.equals(this.status, orderAuthorizeResponse.status) &&
        Objects.equals(this.links, orderAuthorizeResponse.links)&&
        Objects.equals(this.additionalProperties, orderAuthorizeResponse.additionalProperties);
  }

  @Override
  public int hashCode() {
    return Objects.hash(createTime, updateTime, id, paymentSource, intent, processingInstruction, payer, purchaseUnits, status, links, additionalProperties);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class OrderAuthorizeResponse {\n");
    sb.append("    createTime: ").append(toIndentedString(createTime)).append("\n");
    sb.append("    updateTime: ").append(toIndentedString(updateTime)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    paymentSource: ").append(toIndentedString(paymentSource)).append("\n");
    sb.append("    intent: ").append(toIndentedString(intent)).append("\n");
    sb.append("    processingInstruction: ").append(toIndentedString(processingInstruction)).append("\n");
    sb.append("    payer: ").append(toIndentedString(payer)).append("\n");
    sb.append("    purchaseUnits: ").append(toIndentedString(purchaseUnits)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    links: ").append(toIndentedString(links)).append("\n");
    sb.append("    additionalProperties: ").append(toIndentedString(additionalProperties)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("create_time");
    openapiFields.add("update_time");
    openapiFields.add("id");
    openapiFields.add("payment_source");
    openapiFields.add("intent");
    openapiFields.add("processing_instruction");
    openapiFields.add("payer");
    openapiFields.add("purchase_units");
    openapiFields.add("status");
    openapiFields.add("links");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to OrderAuthorizeResponse
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!OrderAuthorizeResponse.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in OrderAuthorizeResponse is not found in the empty JSON string", OrderAuthorizeResponse.openapiRequiredFields.toString()));
        }
      }
      if ((jsonObj.get("create_time") != null && !jsonObj.get("create_time").isJsonNull()) && !jsonObj.get("create_time").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `create_time` to be a primitive type in the JSON string but got `%s`", jsonObj.get("create_time").toString()));
      }
      if ((jsonObj.get("update_time") != null && !jsonObj.get("update_time").isJsonNull()) && !jsonObj.get("update_time").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `update_time` to be a primitive type in the JSON string but got `%s`", jsonObj.get("update_time").toString()));
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      // validate the optional field `payment_source`
      if (jsonObj.get("payment_source") != null && !jsonObj.get("payment_source").isJsonNull()) {
        PaymentSourceResponse.validateJsonObject(jsonObj.getAsJsonObject("payment_source"));
      }
      // validate the optional field `payer`
      if (jsonObj.get("payer") != null && !jsonObj.get("payer").isJsonNull()) {
        Payer.validateJsonObject(jsonObj.getAsJsonObject("payer"));
      }
      if (jsonObj.get("purchase_units") != null && !jsonObj.get("purchase_units").isJsonNull()) {
        JsonArray jsonArraypurchaseUnits = jsonObj.getAsJsonArray("purchase_units");
        if (jsonArraypurchaseUnits != null) {
          // ensure the json data is an array
          if (!jsonObj.get("purchase_units").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `purchase_units` to be an array in the JSON string but got `%s`", jsonObj.get("purchase_units").toString()));
          }

          // validate the optional field `purchase_units` (array)
          for (int i = 0; i < jsonArraypurchaseUnits.size(); i++) {
            PurchaseUnit.validateJsonObject(jsonArraypurchaseUnits.get(i).getAsJsonObject());
          };
        }
      }
      if (jsonObj.get("links") != null && !jsonObj.get("links").isJsonNull()) {
        JsonArray jsonArraylinks = jsonObj.getAsJsonArray("links");
        if (jsonArraylinks != null) {
          // ensure the json data is an array
          if (!jsonObj.get("links").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `links` to be an array in the JSON string but got `%s`", jsonObj.get("links").toString()));
          }

          // validate the optional field `links` (array)
          for (int i = 0; i < jsonArraylinks.size(); i++) {
            LinkDescription.validateJsonObject(jsonArraylinks.get(i).getAsJsonObject());
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!OrderAuthorizeResponse.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'OrderAuthorizeResponse' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<OrderAuthorizeResponse> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(OrderAuthorizeResponse.class));

       return (TypeAdapter<T>) new TypeAdapter<OrderAuthorizeResponse>() {
           @Override
           public void write(JsonWriter out, OrderAuthorizeResponse value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             obj.remove("additionalProperties");
             // serialize additonal properties
             if (value.getAdditionalProperties() != null) {
               for (Map.Entry<String, Object> entry : value.getAdditionalProperties().entrySet()) {
                 if (entry.getValue() instanceof String)
                   obj.addProperty(entry.getKey(), (String) entry.getValue());
                 else if (entry.getValue() instanceof Number)
                   obj.addProperty(entry.getKey(), (Number) entry.getValue());
                 else if (entry.getValue() instanceof Boolean)
                   obj.addProperty(entry.getKey(), (Boolean) entry.getValue());
                 else if (entry.getValue() instanceof Character)
                   obj.addProperty(entry.getKey(), (Character) entry.getValue());
                 else {
                   obj.add(entry.getKey(), gson.toJsonTree(entry.getValue()).getAsJsonObject());
                 }
               }
             }
             elementAdapter.write(out, obj);
           }

           @Override
           public OrderAuthorizeResponse read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             // store additional fields in the deserialized instance
             OrderAuthorizeResponse instance = thisAdapter.fromJsonTree(jsonObj);
             for (Map.Entry<String, JsonElement> entry : jsonObj.entrySet()) {
               if (!openapiFields.contains(entry.getKey())) {
                 if (entry.getValue().isJsonPrimitive()) { // primitive type
                   if (entry.getValue().getAsJsonPrimitive().isString())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsString());
                   else if (entry.getValue().getAsJsonPrimitive().isNumber())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsNumber());
                   else if (entry.getValue().getAsJsonPrimitive().isBoolean())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsBoolean());
                   else
                     throw new IllegalArgumentException(String.format("The field `%s` has unknown primitive type. Value: %s", entry.getKey(), entry.getValue().toString()));
                 } else if (entry.getValue().isJsonArray()) {
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), List.class));
                 } else { // JSON object
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), HashMap.class));
                 }
               }
             }
             return instance;
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of OrderAuthorizeResponse given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of OrderAuthorizeResponse
  * @throws IOException if the JSON string is invalid with respect to OrderAuthorizeResponse
  */
  public static OrderAuthorizeResponse fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, OrderAuthorizeResponse.class);
  }

 /**
  * Convert an instance of OrderAuthorizeResponse to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

